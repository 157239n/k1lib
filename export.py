#!/usr/bin/env python

# to refresh all files, just do `./export.py`
# to refresh all files and install everywhere: `./export.py --dist=True`
# to refresh just 1 file without dependency on k1lib: `./export.py cli/grep --bootstrap=True`. This is useful when k1lib is kinda

import json, fire, os, re, warnings, traceback, sys
os.chdir(os.path.dirname(os.path.realpath(__file__)))

try: from k1lib.imports import *; hasK1 = True
except Exception as e: hasK1 = False; traceback.print_exc()

def broken():
    if not hasK1: raise Exception("k1lib is in a broken state right now. Can't perform exportAll(). Please fix it before doing this operation")

def export(nb:str=None, inject:bool=True, dist:bool=False, upload:bool=False, bootstrap:bool=False) -> None:
    """Exports cells in a notebook that has the "#export" tab in the first line
into a regular python file. If `filename` is not given, will take the file name
of the notebook. The root directory will always be that of the k1lib library.

:param nb: file path of the notebook. If not specified, then will do it to all files
:param inject: whether to inject in the "# deref()" at the end of each line or not (to make error messages more readable)
:param dist: whether to distributedly install k1lib to all nodes in the cluster
:param bootstrap: put False if you want the simple version without dependency on k1lib
"""
    print(f"./export started up - {sys.executable}")
    if bootstrap or not hasK1: # if k1 is in working state, then just export the whole thing, it's pretty quick. If it's not, then do the vanilla Python version to fix that one particular notebook file
        print("----- bootstrapping")
        if nb:
            answer = ["# AUTOGENERATED FILE! PLEASE DON'T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD"]
            stub = f"k1lib"
            #filename = f"{stub}/{filename or nb.split('/')[-1].replace('.ipynb', '.py')}"
            print(f"Current dir: {os.getcwd()}, {__file__}")
            #print(f"File: {filename}")
            for cell in json.loads(open(f"{stub}/{nb}.ipynb").read())["cells"]:
                if cell["cell_type"] != "code": continue
                source = cell["source"]
                if len(source) <= 0: continue
                if not source[0].startswith("#export"): continue
                answer.append("".join(source[1:]))
            with open(f"{stub}/{nb}.py", 'w+') as f: f.write("\n".join(answer))
    else: exportAll()
            
    install()
    if upload or dist: uploadF()
    if dist: distributedInstall()

def uploadF(): # installs in the local pypi server
    None | cmd("cd ~/k1lib && rm -rf ~/pypi/k1lib && mkdir -p ~/pypi/k1lib && rm -rf dist && python -m build && mv dist/* ~/pypi/k1lib/") | ignore()
    ls("~/pypi/k1lib") | apply(op().split("/")[-1]) | apply(lambda x: f"<a href='{x}'>{x}</a>") | join("") | aS(lambda x: f"<html>{x}</html>") | file("~/pypi/k1lib/index.html")

def distributedInstall():
    applyCl.nodeIds(False) | applyCl.aS(lambda: None | cmd("pip cache purge") | deref()) | deref()
    applyCl.nodeIds(False) | applyCl.aS(lambda: None | cmd("pip uninstall k1lib -y && pip install k1lib") | deref()) | deref()

def oldDistributedInstall(): # installs the library in all nodes, should take 8-15s to complete
    base = "/home/kelvin/repos/labs/k1lib"; broken(); print("Starting distributedInstall()...")
    try: applyCl.nodeIds(False) | applyCl.aS(lambda: None | cmd(f"rm -rf {base} && mkdir -p {base}") | deref()) | deref()
    except: pass
    None | cmd(f"cd {base} && ./distribute.sh") | ignore()
    with k1.captureStdout(True):
        applyCl.nodeIds(False) | applyCl.aS(lambda: None | cmd(f"cd {base} && unzip dist.pth && pip install .") | deref()) | ignore()
    print("Finished distributedInstall()")

def install():
    os.system("rm -rf build dist k1lib.egg-info __pycache__")
    os.system("pip uninstall -y k1lib")
    os.system(f"pip install .")

arr = []
def expandDomain(it):
    last = None; inQuoteBlock = 0; quotePat = re.compile('"""')
    n = it | cut(0) | apply(len) | toMax()
    for a, b in it: # a is line code, b is whether it has the pattern "class abc(BaseCli)" or not
        if b: last = b
        inQuoteBlock = (inQuoteBlock + len(quotePat.findall(a))) % 2
        arr.append(inQuoteBlock)
        if inQuoteBlock == 1 or last is None or a.endswith("\\"): yield a; continue
        yield f"{a.ljust(80)} # {last or ''}"
pat1 = re.compile("^class (?P<abc>\\w*)")
pat2 = re.compile("^def (?P<abc>\\w*)\\(")
def exportAll():
    print("----- exportAll")
    broken()
    # .ipynb files
    # fns = os.walk("/home/kelvin/repos/labs/k1lib") | cut(0, 2) | ungroup() | join("/").all() | grep(".py$") & grep(".ipynb$") | joinStreams() | apply(op().split(".") | tail(1).split() | item() + join(".")) | groupBy(0, True) | apply(item().all(), 1) | apply(list, 1) | filt("len(x) == 2", 1) | cut(0) | ~grep("checkpoint") | deref()
    fns = os.walk("/home/quang/k1lib") | cut(0, 2) | ungroup() | join("/").all() | grep(".py$") & grep(".ipynb$") | joinStreams() | apply(op().split(".") | head(-1).split() | join(".") + item()) | groupBy(0, True) | apply(item().all(), 1) | apply(list, 1) | filt("len(x) == 2", 1) | cut(0) | ~grep("checkpoint") | deref()
    if len(fns) == 0: raise Exception("Something went wrong, no notebook files found")
    for fn in fns: f"{fn}.ipynb" | nb.cells() | filt("x['cell_type'] == 'code'") | nb.pretty(whitelist=["export"]) | op()["source"][1:].all() | joinStreams() | apply("[x,x]") | apply(tryout() | aS(lambda x: pat1.search(x) or pat2.search(x)) | op().group("abc"), 1) | deref() | aS(expandDomain) | insert("# AUTOGENERATED FILE! PLEASE DON'T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD") | file(f"{fn}.py")
    arr | count() | display()

fire.Fire(export)


#!/usr/bin/env python3

# to refresh all files, just do `./export.py`
# to refresh all files and install everywhere: `./export.py --dist=True`

import json, fire, os, re, warnings, traceback
os.chdir(os.path.dirname(os.path.realpath(__file__)))

try: from k1lib.imports import *; hasK1 = True
except Exception as e: hasK1 = False; traceback.print_exc()

def broken():
    if not hasK1: raise Exception("k1lib is in a broken state right now. Can't perform exportAll(). Please fix it before doing this operation")

def export(nb:str=None, inject:bool=True, dist:bool=False, bootstrap:bool=True) -> None:
    """Exports cells in a notebook that has the "#export" tab in the first line
into a regular python file. If `filename` is not given, will take the file name
of the notebook. The root directory will always be that of the k1lib library.

:param nb: file path of the notebook. If not specified, then will do it to all files
:param inject: whether to inject in the "# deref()" at the end of each line or not (to make error messages more readable)
:param dist: whether to distributedly install k1lib to all nodes in the cluster
:param bootstrap: put False if you want the simple version
"""
    if bootstrap and hasK1: exportAll() # if k1 is in working state, then just export the whole thing, it's pretty quick. If it's not, then do the vanilla Python version to fix that one particular notebook file
    else:
        if nb:
            answer = ["# AUTOGENERATED FILE! PLEASE DON'T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD"]
            stub = f"k1lib"
            #filename = f"{stub}/{filename or nb.split('/')[-1].replace('.ipynb', '.py')}"
            print(f"Current dir: {os.getcwd()}, {__file__}")
            #print(f"File: {filename}")
            for cell in json.loads(open(f"{stub}/{nb}.ipynb").read())["cells"]:
                if cell["cell_type"] != "code": continue
                source = cell["source"]
                if len(source) <= 0: continue
                if not source[0].startswith("#export"): continue
                answer.append("".join(source[1:]))
            with open(f"{stub}/{nb}.py", 'w+') as f: f.write("\n".join(answer))
            
    install(dist)

def distributedInstall(): # installs the library in all nodes, should take 8-15s to complete
    base = "/home/kelvin/repos/labs/k1lib"; broken(); print("Starting distributedInstall()...")
    try: applyCl.nodeIds(False) | applyCl.aS(lambda: None | cmd(f"rm -rf {base} && mkdir -p {base}") | deref()) | deref()
    except: pass
    None | cmd(f"cd {base} && ./distribute.sh") | ignore()
    with k1.captureStdout(True):
        applyCl.nodeIds(False) | applyCl.aS(lambda: None | cmd(f"cd {base} && unzip dist.pth && pip install .") | deref()) | ignore()
    print("Finished distributedInstall()")

def install(dist=False):
    os.system("rm -r build dist k1lib.egg-info __pycache__")
    os.system("pip uninstall -y k1lib")
    os.system(f"./setup.py install")
    if dist: distributedInstall()

arr = []
def expandDomain(it):
    last = None; inQuoteBlock = 0; quotePat = re.compile('"""')
    n = it | cut(0) | apply(len) | toMax()
    for a, b in it: # a is line code, b is whether it has the pattern "class abc(BaseCli)" or not
        if b: last = b
        inQuoteBlock = (inQuoteBlock + len(quotePat.findall(a))) % 2
        arr.append(inQuoteBlock)
        if inQuoteBlock == 1 or last is None or a.endswith("\\"): yield a; continue
        yield f"{a.ljust(80)} # {last or ''}"
pat1 = re.compile("^class (?P<abc>\w*)")
pat2 = re.compile("^def (?P<abc>\w*)\(")
def exportAll():
    broken()
    # .ipynb files
    # fns = os.walk("/home/kelvin/repos/labs/k1lib") | cut(0, 2) | ungroup() | join("/").all() | grep(".py$") & grep(".ipynb$") | joinStreams() | apply(op().split(".") | tail(1).split() | item() + join(".")) | groupBy(0, True) | apply(item().all(), 1) | apply(list, 1) | filt("len(x) == 2", 1) | cut(0) | ~grep("checkpoint") | deref()
    fns = os.walk("/home/kelvin/repos/labs/k1lib") | cut(0, 2) | ungroup() | join("/").all() | grep(".py$") & grep(".ipynb$") | joinStreams() | apply(op().split(".") | head(-1).split() | join(".") + item()) | groupBy(0, True) | apply(item().all(), 1) | apply(list, 1) | filt("len(x) == 2", 1) | cut(0) | ~grep("checkpoint") | deref()
    if len(fns) == 0: raise Exception("Something went wrong, no notebook files found")
    for fn in fns: f"{fn}.ipynb" | nb.cells() | filt("x['cell_type'] == 'code'") | nb.pretty(whitelist=["export"]) | op()["source"][1:].all() | joinStreams() | apply("[x,x]") | apply(tryout() | aS(lambda x: pat1.search(x) or pat2.search(x)) | op().group("abc"), 1) | deref() | aS(expandDomain) | insert("# AUTOGENERATED FILE! PLEASE DON'T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD") | file(f"{fn}.py")
    arr | count() | display()

fire.Fire(export)


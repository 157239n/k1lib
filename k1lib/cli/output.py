# AUTOGENERATED FILE! PLEASE DON'T EDIT
"""
For operations that feel like the termination
"""
from collections import defaultdict
from typing import Iterator, Any
from k1lib.cli.init import BaseCli, Table
import torch, numbers, numpy as np, k1lib; from k1lib import cli
__all__ = ["stdout", "file", "pretty", "display", "headOut", "intercept"]
class stdout(BaseCli):
    """Prints out all lines. If not iterable, then print out the input raw.
Example::

    # prints out "0\\n1\\n2"
    range(3) | stdout()
    # same as above, but (maybe?) more familiar
    range(3) > stdout()"""
    def __ror__(self, it:Iterator[str]):
        try:
            it = iter(it)
            for line in it: print(line)
        except TypeError: print(it)
class file(BaseCli):
    def __init__(self, fileName:str, text:bool=True):
        """Opens a new file for writing.
Example::

    # writes "0\\n1\\n2\\n" to file
    range(3) | file("test/f.txt")
    # same as above, but (maybe?) more familiar
    range(3) > file("text/f.txt")
    # returns ['0', '1', '2']
    cat("folder/f.txt") | deref()

    # writes bytes to file
    b'5643' | file("test/a.bin", False)
    # returns ['5643']
    cat("test/a.bin") | deref()

:param text: if True, accepts Iterator[str], and prints out each string on a
    new line. Else accepts bytes and write in 1 go."""
        super().__init__(); self.fileName = fileName; self.text = text
    def __ror__(self, it:Iterator[str]) -> None:
        super().__ror__(it)
        if self.text:
            with open(self.fileName, "w") as f:
                for line in it: f.write(f"{line}\n")
        else:
            with open(self.fileName, "wb") as f: f.write(it)
class pretty(BaseCli):
    """Pretty prints a table. Not really used directly.
Example::

    # These 2 statements are pretty much the same
    [range(10), range(10)] | head(5) | pretty() > stdout()
    [range(10), range(10)] | display()"""
    def __ror__(self, it:Table[Any]) -> Iterator[str]:
        table = []; widths = defaultdict(lambda: 0)
        for row in it:
            _row = []
            for i, e in enumerate(row):
                e = f"{e}"; _row.append(e)
                widths[i] = max(len(e), widths[i])
            table.append(_row)
        for row in table:
            s = ""
            for w, e in zip(widths.values(), row):
                s += e.rstrip(" ").ljust(w+3)
            yield s
def display(lines:int=10):
    """Convenience method for displaying a table"""
    f = pretty() | stdout()
    if lines is None: return f
    else: return cli.head(lines) | f
def headOut(lines:int=10):
    """Convenience method for head() | stdout()"""
    if lines is None: return stdout()
    else: return cli.head(lines) | stdout()
class intercept(BaseCli):
    def __init__(self, raiseError:bool=True):
        """Intercept flow at a particular point, analyze the object piped in, and
raises error to stop flow. Example::

    3 | intercept()

:param raiseError: whether to raise error when executed or not."""
        self.raiseError = raiseError
    def __ror__(self, s):
        print(type(s))
        if isinstance(s, (numbers.Number, str, bool)):
            print(k1lib.tab(f"{s}"))
        elif isinstance(s, (tuple, list)):
            print(k1lib.tab(f"Length: {len(s)}"))
            for e in s: print(k1lib.tab(f"- {type(e)}"))
        elif isinstance(s, (np.ndarray, torch.Tensor)):
            print(k1lib.tab(f"Shape: {s.shape}"))
            if s.numel() < 1000:
                print(k1lib.tab(f"{s}"))
        if self.raiseError: raise RuntimeError("intercepted")
        return s
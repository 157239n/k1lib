# AUTOGENERATED FILE! PLEASE DON'T EDIT
from k1lib.callbacks import Callback, Callbacks
class LossLandscape(Callback):
    """Plots the loss landscape of the network. Display
    this in your cell for more."""
    def __init__(self):
        super(LossLandscape, self).__init__()
    def plot(self):
        print() # nice new line
        self.cbs.suspend(["HookModule", "HookParam", "ProgressBar", "ParamScheduler"])
        self.cbs("startRun"); self.cbs("startEpisode")
        self.learner.xb, self.learner.yb = next(iter(self.learner.data.valid))
        self.cbs("startBatch"); _k1lib.clearLine()
        model = self.learner.model
        vector1 = _k1lib.getParamsVector(model)
        vector2 = _k1lib.getParamsVector(model)
        def calc(_range=[-1, 1]):
            res = 50
            x, y = _torch.meshgrid(_torch.linspace(_range[0], _range[1], res), torch.linspace(_range[0], _range[1], res))
            z = _np.empty((res, res))
            with _torch.no_grad():
                originalParams = _k1lib.exportParams(model)
                for ix, _ in enumerate(x):
                    for iy, _ in enumerate(y):
                        for param, og, v1, v2 in zip(model.parameters(), originalParams, vector1, vector2):
                            param.data = og + x[ix, iy] * v1 + y[ix, iy] * v2
                        self.learner.y = self.learner.model(self.xb); self.cbs("endPass")
                        z[ix, iy] = self.lossF(self.y, self.yb) / self.xb.shape[0]
                        print(f"\rProgress: {round(100*(ix+iy/res)/res)}%     ", end="")
                _k1lib.importParams(self.learner.model, originalParams)
            return x, y, z
        fig, ax = _plt.subplots(subplot_kw={"projection": "3d"}, ncols=4, figsize=(16, 4), dpi=120)
        ax[0].plot_surface(*calc([-.1, .1]), cmap=_plt.cm.coolwarm);   print(" 1/4 Finished [-0.1, 0.1] range  ", end="")
        ax[1].plot_surface(*calc([-.32, .32]), cmap=_plt.cm.coolwarm); print(" 2/4 Finished [-0.32, 0.32] range", end="")
        ax[2].plot_surface(*calc([-1, 1]), cmap=_plt.cm.coolwarm);     print(" 3/4 Finished [-1, 1] range      ", end="")
        ax[3].plot_surface(*calc([-3.2, 3.2]), cmap=_plt.cm.coolwarm); print(" 4/4 Finished [-3.2, 3.2] range  ", end="")
        self.cbs("endBatch"); self.cbs("endEpisode"); self.cbs("endRun")
        _plt.show()
        self.cbs.restore()
    def __repr__(self):
        return f"{super().__repr__()}, use...\n" +\
                "- `.plot()` for the 3 main plots"
Callbacks.withLossLandscape = lambda self: self.append(LossLandscape())
Callbacks.withLossLandscape.__doc__ = LossLandscape.__doc__
Callback.cls.LossLandscape = LossLandscape
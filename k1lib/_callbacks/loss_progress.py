# AUTOGENERATED FILE! PLEASE DON'T EDIT
from k1lib.callbacks import Callback, Callbacks
import k1lib, time as _time, numpy as _np
from functools import partial
import matplotlib.pyplot as plt
@k1lib.patch(Callback.cls)
class ProgressBar(Callback):
    """Displays the current progress, epoch and batch while running."""
    def startRun(self):
        self.startTime = _time.time()
        self.step = 0
    def startBatch(self):
        self.elapsedTime = _time.time() - self.startTime
        self.step += 1
        self.learner.progress = (self.batch / self.nBatches + self.epoch) / self.epochs
        if self.step % 10 == 0:
            print(f"\rProgress: {round(100 * self.progress)}%, epoch: {self.epoch}/{self.epochs}, batch: {self.batch}/{self.nBatches}, elapsed: {round(self.elapsedTime, 2)}s         ", end="")
@k1lib.patch(Callbacks, docs=ProgressBar)
def withProgressBar(self): return self.append(ProgressBar())
def plotFragment(obj, _slice, subplot, label):
    plt.subplot(1, 2, subplot);
    plt.plot(range(len(obj))[_slice], obj[_slice])
    plt.title(f"{label} loss")
def plotF(obj, _slice): # actual function stored by the sliceable plot
    plt.figure(figsize=(10, 3), dpi=100)
    plotFragment(obj.train, _slice, 1, "Train")
    plotFragment(obj.valid, _slice, 2, "Valid")
    plt.show()
def commonPlot(obj):
    return k1lib.viz.SliceablePlot(partial(plotF, obj), slice(None, None, None))
def nonEmptyList(_list):
    return [0] if _list == [] else _list
@k1lib.patch(Callback.cls)
class Loss(Callback):
    "Records losses after each batch. Display this in your cell for more"
    def __init__(self):
        super().__init__()
        self.train = []; self.valid = [] # all stats all times
        # average stats for each epoch
        self.epoch = k1lib.Object.fromDict({"train": [], "valid": []})\
                        .withRepr("Use...\n" +\
                                 "- `.train` for epoch-averaged training losses\n" +\
                                 "- `.valid` for epoch-averaged validation losses\n" +\
                                 "- `.plot()` to plot the 2 above")
        self.plot = partial(commonPlot, self)
        self.epoch.plot = partial(commonPlot, self.epoch)
        self._trainLosses = []; self._validLosses = []
    def endLoss(self):
        if self.model.training:
            self._trainLosses.append(self.loss/self.xb.shape[0])
        else: self._validLosses.append(self.loss/self.xb.shape[0])
    def endEpoch(self):
        self.train.extend(self._trainLosses); self.epoch.train.append(_np.mean(nonEmptyList(self._trainLosses)))
        self.valid.extend(self._validLosses); self.epoch.valid.append(_np.mean(nonEmptyList(self._validLosses)))
        self._trainLosses = []; self._validLosses = []
    def __repr__(self):
        return f"""{super()._reprHead}, use...
- cb.train: for all training losses over all epochs and batches (#epochs * #batches)
- cb.valid: for all validation losses over all epochs and batches (#epochs * #batches)
- cb.plot(): to plot the 2 above
- cb.epoch: for average losses of each epochs
{super()._reprCan}"""
@k1lib.patch(Callbacks, docs=Loss)
def withLoss(self): return self.append(Loss())
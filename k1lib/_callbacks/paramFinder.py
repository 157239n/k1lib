# AUTOGENERATED FILE! PLEASE DON'T EDIT
from k1lib.callbacks import Callback, Callbacks
import k1lib, numpy as np
import matplotlib.pyplot as plt
@k1lib.patch(Callback.cls)
class ParamFinder(Callback):
    """Automatically finds out the right value for
    a specific parameter"""
    def __init__(self, param:str="lr", samples=300):
        super().__init__(); self.order = 20
        self.param = param; self.samples = samples
        self.activated = False
    @property
    def samples(self): return self._samples
    @samples.setter
    def samples(self, samples):
        self._samples = samples
        self.potentialValues = 10**np.linspace(-6, 2, samples)
    @property
    def value(self):
        if self.idx >= len(self.potentialValues): raise k1lib.CancelRunException("Checked all possible param values")
        return self.potentialValues[self.idx]
    @property
    def lossAvgs(self): return sum(self.losses[-2:])/2
    def startBatch(self):
        if self.activated:
            self.idx += 1
            for paramGroup in self.opt.param_groups:
                paramGroup[self.param] = self.value
    def endLoss(self):
        if self.activated:
            self.losses.append(self.loss)
            lossAvgs = self.lossAvgs
            if lossAvgs < self.bestLoss:
                self.best = self.value
                self.bestLoss = lossAvgs
            if lossAvgs > self.bestLoss * 10: raise k1lib.CancelRunException("Loss increases significantly")
    def run(self):
        self.idx = 0; self.losses = []; self.best = None; self.bestLoss = float("inf")
        self.activated = True; ogParams = self.model.exportParams()
        self.learner.cbs.suspend(["HookModule", "HookParam", "ParamScheduler", "Loss", "Autosave"])
        self.learner.run(int(1e3))
        self.activated = False; self.model.importParams(ogParams)
        self.learner.cbs.restore(); self.plot()
    def plot(self):
        if len(self.losses) == 0: print("Has not run param finder yet.")
        else:
            print(f"Suggested param: {self.best / 2}"); plt.figure(dpi=120)
            plt.plot(self.potentialValues[:len(self.losses)], self.losses)
            plt.xscale("log"); plt.xlabel(self.param); plt.ylabel("Loss"); plt.show()
    def __repr__(self):
        return f"""{self._reprHead}, use...
- pf.run(): to start scanning for good params and automatically plots
- pf.plot(): to plot
- pf.samples = ...: to set how many param values to iterate through
{self._reprCan}"""
@k1lib.patch(Callbacks, docs=ParamFinder)
def withParamFinder(self, param="lr", samples=300):
    return self.append(ParamFinder(param))
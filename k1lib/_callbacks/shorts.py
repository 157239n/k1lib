# AUTOGENERATED FILE! PLEASE DON'T EDIT
from k1lib.callbacks import Callback, Callbacks
import k1lib, os
@k1lib.patch(Callback.cls)
class Autosave(Callback):
    def endRun(self):
        os.system("mv autosave-1.pth autosave-0.pth")
        os.system("mv autosave-2.pth autosave-1.pth")
        self.learner.save("autosave-2.pth")
@k1lib.patch(Callbacks)
def withAutosave(self): return self.append(Autosave())
@k1lib.patch(Callback.cls)
class DontTrainValid(Callback):
    def _common(self):
        if not self.model.training: return True
    def startBackward(self): return self._common()
    def startStep(self): return self._common()
@k1lib.patch(Callbacks)
def withDontTrainValid(self): return self.append(DontTrainValid())
@k1lib.patch(Callback.cls)
class InspectLoss(Callback):
    """Expected `f` to take in 1 float."""
    def __init__(self, f): super().__init__(); self.f = f
    def endLoss(self): self.f(self.loss.detach())
@k1lib.patch(Callbacks, docs=InspectLoss)
def withInspectLoss(self, f): return self.append(InspectLoss(f))
@k1lib.patch(Callback.cls)
class Cuda(Callback):
    def startRun(self): self.model.cuda()
    def startBatch(self):
        self.learner.xb = self.learner.xb.cuda()
        self.learner.yb = self.learner.yb.cuda()
@k1lib.patch(Callbacks)
def withCuda(self): return self.append(Cuda())
@k1lib.patch(Callback.cls)
class DType(Callback):
    def __init__(self, dtype): super().__init__(); self.dtype = dtype
    def startRun(self): self.model = self.model.to(self.dtype)
    def startBatch(self):
        self.learner.xb = self.learner.xb.to(self.dtype)
        self.learner.yb = self.learner.yb.to(self.dtype)
@k1lib.patch(Callbacks)
def withDType(self, dtype): return self.append(DType(dtype))
@k1lib.patch(Callback.cls)
class InspectBatch(Callback):
    """Expected `f` to take in 2 tensors."""
    def __init__(self, f:callable): super().__init__(); self.f = f
    def startBatch(self): self.f(self.xb, self.yb)
@k1lib.patch(Callbacks, docs=InspectBatch)
def withInspectBatch(self, f): return self.append(InspectBatch(f))
@k1lib.patch(Callback.cls)
class ModifyBatch(Callback):
    """Modifies xb and yb on the fly. Expected `f`
    to take in 2 tensors and return 2 tensors."""
    def __init__(self, f): super().__init__(); self.f = f
    def startBatch(self): self.learner.xb, self.learner.yb = self.f(self.xb, self.yb)
@k1lib.patch(Callbacks, docs=ModifyBatch)
def withModifyBatch(self, f): return self.append(ModifyBatch(f))
@k1lib.patch(Callback.cls)
class InspectOutput(Callback):
    """Expected `f` to take in 1 tensor."""
    def __init__(self, f): super().__init__(); self.f = f
    def endPass(self): self.f(self.y)
@k1lib.patch(Callbacks, docs=InspectOutput)
def withInspectOutput(self, f): return self.append(InspectOutput(f))
@k1lib.patch(Callback.cls)
class ModifyOutput(Callback):
    def __init__(self, f): super().__init__(); self.f = f
    def endPass(self): self.learner.y = self.f(self.y)
@k1lib.patch(Callbacks)
def withModifyOutput(self, f): return self.append(ModifyOutput(f))
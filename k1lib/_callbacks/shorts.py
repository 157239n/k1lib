# AUTOGENERATED FILE! PLEASE DON'T EDIT
from k1lib.callbacks import Callback, Callbacks
import k1lib
@k1lib.patch(Callback.cls)
class InspectLoss(Callback):
    def __init__(self, f): super().__init__(); self.f = f
    def endLoss(self): self.f(self.loss.detach())
@k1lib.patch(Callbacks)
def withInspectLoss(self, f):
    """Expected `f` to take in 1 float."""
    return self.append(InspectLoss(f))
@k1lib.patch(Callback.cls)
class Cuda(Callback):
    def startRun(self): self.model.cuda()
    def startBatch(self):
        self.learner.xb = self.learner.xb.cuda()
        self.learner.yb = self.learner.yb.cuda()
@k1lib.patch(Callbacks)
def withCuda(self): return self.append(Cuda())
@k1lib.patch(Callback.cls)
class DType(Callback):
    def __init__(self, dtype): super().__init__(); self.dtype = dtype
    def startRun(self): self.model = self.model.to(self.dtype)
    def startBatch(self):
        self.learner.xb = self.learner.xb.to(self.dtype)
        self.learner.yb = self.learner.yb.to(self.dtype)
@k1lib.patch(Callbacks)
def withDType(self, dtype): return self.append(DType(dtype))
@k1lib.patch(Callback.cls)
class InspectBatch(Callback):
    """Expected `f` to take in 2 tensors."""
    def __init__(self, f:callable): super().__init__(); self.f = f
    def startBatch(self): self.f(self.xb, self.yb)
@k1lib.patch(Callbacks)
def withInspectBatch(self, f): return self.append(InspectBatch(f))
@k1lib.patch(Callback.cls)
class ModifyBatch(Callback):
    """Modifies xb and yb on the fly. Expected `f`
    to take in 2 tensors and return 2 tensors."""
    def __init__(self, f): super().__init__(); self.f = f
    def startBatch(self): self.learner.xb, self.learner.yb = self.f(self.xb, self.yb)
@k1lib.patch(Callbacks)
def withModifyBatch(self, f): return self.append(ModifyBatch(f))
@k1lib.patch(Callback.cls)
class InspectOutput(Callback):
    """Expected `f` to take in 1 tensor."""
    def __init__(self, f): super().__init__(); self.f = f
    def endPass(self): self.f(self.y)
@k1lib.patch(Callbacks)
def withInspectOutput(self, f): return self.append(InspectOutput(f))
@k1lib.patch(Callback.cls)
class ModifyOutput(Callback):
    def __init__(self, f): super().__init__(); self.f = f
    def endPass(self): self.learner.y = self.f(self.y)
@k1lib.patch(Callbacks)
def withModifyOutput(self, f): return self.append(ModifyOutput(f))
# AUTOGENERATED FILE! PLEASE DON'T EDIT
def __repr__():
    return"""
Some docs for data module
"""
import torch as _torch, math as _math, k1lib as _k1lib
import numpy as _np, matplotlib.pyplot as _plt
from functools import partial as _partial
class Sampler:
    def __init__(self, dataset, batchSize:int):
        """Creates a random sampler.

Basically, when given a dataset with length n and
batch size, this will split things up into n/batchSize
batches. Then, when indexed by an integer, this will
return a range of the dataset.

Args:
    dataset: any object that implements __getitem__() and __len__()
    batchSize: integer
        """
        n = len(dataset)
        self.dataset = dataset
        self.nBatches = _math.ceil(n / batchSize)
        self.batchSize = batchSize
        self.idxs = _np.random.permutation(n)
    def __len__(self):
        return self.nBatches
    def __getitem__(self, i):
        items = self.idxs[i*self.batchSize:(i+1)*self.batchSize]
        xs, ys = [], []
        for item in items:
            x, y = self.dataset[item]
            xs.append(x); ys.append(y)
        return _torch.tensor(xs), _torch.tensor(ys)
    def __iter__(self):
        return (self[i] for i in range(self.nBatches))
class DataLoader:
    def __init__(self, fGenerator:callable, length:int):
        """Creates a new DataLoader

Args:
    fGenerator: a function when called upon generates a batch
        generator. Aka `batch next(fGenerator())`
    length: length of generator
"""
        self.fGenerator = fGenerator # when called upon, generates a new generator
        self.length = length
        self.sample = next(iter(self))
    def __call__(self): return self.fGenerator()
    def __len__(self): return self.length
    def __iter__(self):
        return self.fGenerator()
        #for elem in self.fGenerator(): yield elem
    def __repr__(self):
        return f"""DataLoader object. {len(self)} batches total, use...
- for data in dl: print(data)
- it = iter(dl); data = next(it)
- len(dl): to get dataloader's length
- dl.sample: to get a sample of the data"""
def _gen(sampler, _range): return (sampler[idx] for idx in _range)
def _common(sampler, _range:range):
    return DataLoader(_partial(_gen, sampler, _range), len(_range))
class Data:
    """Just a shell, containing 2 DataLoaders, `train` and `valid`"""
    def __init__(self, train:DataLoader, valid:DataLoader):
        """Expecting train and valid to each return a generator when called upon"""
        self.train = train; self.valid = valid
    @staticmethod
    def fromDataset(dataset, batchSize, trainSplit=0.8):
        sampler = Sampler(dataset, batchSize); numBatches = len(sampler)
        mid = _math.ceil(trainSplit * numBatches)
        trainRange = range(0, mid)
        testRange = range(mid, numBatches)
        return Data(_common(sampler, trainRange), _common(sampler, testRange))
    def __repr__(self):
        return "`Data` object, just a shell containing 2 `DataLoader`s: `.train` and `.valid`"
@_k1lib.patch(_torch.utils.data.DataLoader)
def __repr__(self):
    return "DataLoader of:\n" + _k1lib.tab(self.dataset.__repr__())
class FunctionDataset(_torch.utils.data.Dataset):
    """
    A dataset tailored for 1->1 functions. Have several
    prebuilt datasets:
    - `.exp`: e^x
    - `.log`: ln(x)
    - `.inverse`: 1/x
    - `.linear`: 2x + 8
    - `.sin`: sin(x)
    """
    def __init__(self, function: callable, _range=[-5, 5], samples: int=300):
        """Creates a new dataset, with a specific function.
Args:
    function: first order function, takes in an `x` variable
    _range: range of x
    samples: how many x in specified range
"""
        self.function = function
        self._range = _k1lib.Range(_range)
        self.samples = samples
        self._xsCache = None; self._ysCache = None
    def __len__(self): return self.samples
    def __getitem__(self, index):
        if isinstance(index, slice):
            nRange = _k1lib.Range([0, len(self)])
            _range = _k1lib.Range(index.start if index.start != None else self._range[0], index.stop if index.stop != None else self._range[1])
            samples = round(self._range.toRange(nRange, _range.stop)) - round(self._range.toRange(nRange, _range.start))
            return FunctionDataset(self.function, _range=_range, samples=samples)
        else:
            x = index/self.samples * (self._range[1] - self._range[0]) + self._range[0]
            return _torch.tensor([x], dtype=_torch.bfloat16), _torch.tensor(self.function(x), dtype=_torch.bfloat16)
    def split(self, fraction):
        middle = self._range.fromUnit(fraction)
        return self[:middle], self[middle:]
    @property
    def xs(self):
        if self._xsCache == None:
            self._xsCache = []
            for i in range(len(self)): self._xsCache.append(self[i][0])
            self._xsCache = _torch.Tensor(self._xsCache)
        return self._xsCache
    @property
    def ys(self):
        if self._ysCache == None:
            self._ysCache = []
            for i in range(len(self)): self._ysCache.append(self[i][1])
            self._ysCache = _torch.Tensor(self._ysCache)
        return self._ysCache
    def dl(self, shuffle=True, batch_size=32, **kwargs):
        return _torch.utils.data.DataLoader(self, shuffle=shuffle, batch_size=batch_size, **kwargs)
    def __repr__(self):
        _plt.plot(self.xs, self.ys, "."); _plt.show()
        return """Simple 1->1 function dataset. Can do:
- a.dl(): to get PyTorch's DataLoader object
- a.xs: to get a tensor of all x values
- a.ys: to get a tensor of all y values
- len(a): to get length of dataset
- a[i]: to get specific (x, y) element
- a[a:b]: to get another FunctionDataset with a new range [a, b] (same density)
- next(iter(a)): to iterate over all elements"""
FunctionDataset.exp = FunctionDataset(lambda x: _np.exp(x), samples=10000)
FunctionDataset.log = FunctionDataset(lambda x: _np.log(x), _range=[0.01, 5], samples=10000)
FunctionDataset.inverse = FunctionDataset(lambda x: 1/x, samples=10001)
FunctionDataset.linear = FunctionDataset(lambda x: 2*x+8, samples=10000)
FunctionDataset.sin = FunctionDataset(lambda x: _np.sin(x), samples=10000)
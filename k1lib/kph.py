# AUTOGENERATED FILE! PLEASE DON'T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD
"""
This module is for physics and science-related utilities. This is exposed automatically with::

   from k1lib.imports import *
   kph.moody # exposed
"""
import k1lib, base64, io, os, time, math, re; import k1lib.cli as cli; import numpy as np; from collections import deque
__all__ = ["moody", "met", "pDrop"]
def s1f(x): x = math.log(x); return 2.71828182**(4.2444631759401104e-9*x**8 + -8.322685720258006e-7*x**7 + 0.00005619362310993281*x**6 + -0.0019464863019723*x**5 + 0.03964848916369248*x**4 + -0.49797690172977993*x**3 + 3.8239071464559666*x**2 + -16.607415434661515*x**1 + 28.914622582180105*x**0) # s1f
def s2f(x): x = math.log(x); return 2.71828182**(-9.684294546970501e-8*x**8 + 0.000010023037077594955*x**7 + -0.00044729436898422354*x**6 + 0.01121858533408693*x**5 + -0.1724501054794875*x**4 + 1.6561488107502946*x**3 + -9.631636239140226*x**2 + 30.596902063116328*x**1 + -42.275394515360624*x**0) # s2f
def s3f(x): x = math.log(x); return 2.71828182**(-1.9818041355792671e-7*x**8 + 0.000020921872212816747*x**7 + -0.0009533864298367504*x**6 + 0.024465140792683766*x**5 + -0.38609792887414063*x**4 + 3.8291318354577544*x**3 + -23.23172592367326*x**2 + 78.43311842056625*x**1 + -114.66692154593956*x**0) # s3f
def s4f(x): x = math.log(x); return 2.71828182**(-4.9468472029803094e-8*x**8 + 0.000005494960734949219*x**7 + -0.00026226221887305974*x**6 + 0.007007020963456641*x**5 + -0.11419149676364368*x**4 + 1.1553188516399833*x**3 + -7.012207352308602*x**2 + 22.871380160319394*x**1 + -32.31620062330639*x**0) # s4f
def s5f(x): x = math.log(x); return 2.71828182**(-8.363972428531969e-8*x**8 + 0.000008971803962774427*x**7 + -0.0004155739448700786*x**6 + 0.010834753828140732*x**5 + -0.17338070049167648*x**4 + 1.7355279214923196*x**3 + -10.527555418624516*x**2 + 34.85971207801525*x**1 + -49.889296477247974*x**0) # s5f
def s6f(x): x = math.log(x); return 2.71828182**(-1.2802973080810441e-7*x**8 + 0.000013648947845460501*x**7 + -0.0006298244079318834*x**6 + 0.01640949227735026*x**5 + -0.26349567087724807*x**4 + 2.6615934358821742*x**3 + -16.424763357403325*x**2 + 56.05256142596386*x**1 + -82.6895294831373*x**0) # s6f
def s7f(x): x = math.log(x); return 2.71828182**(-4.299576842096641e-8*x**8 + 0.000004994598599082116*x**7 + -0.0002520255217563213*x**6 + 0.007193836039572651*x**5 + -0.12654165516924273*x**4 + 1.3965964485965678*x**3 + -9.359925837562262*x**2 + 34.28529747325624*x**1 + -54.40719644807996*x**0) # s7f
def s8f(x): x = math.log(x); return 2.71828182**(1.269513464498415e-8*x**8 + -0.000001413697846957747*x**7 + 0.00006439485773699122*x**6 + -0.0015472772923693604*x**5 + 0.02092277278431777*x**4 + -0.15581036674222248*x**3 + 0.5826712647881931*x**2 + -1.1472116809058157*x**1 + -0.5287566543646823*x**0) # s8f
def s9f(x): x = math.log(x); return 2.71828182**(5.515220750369853e-8*x**8 + -0.000006432523701620003*x**7 + 0.0003192699893346153*x**6 + -0.00880132344577798*x**5 + 0.14726661041174033*x**4 + -1.5319844824658428*x**3 + 9.719158960604915*x**2 + -34.92379483181018*x**1 + 52.723539185281325*x**0) # s9f
def s10f(x): x = math.log(x); return 2.71828182**(-9.333622374383393e-8*x**8 + 0.000009086789340598601*x**7 + -0.0003779180433109117*x**6 + 0.00876264814162921*x**5 + -0.12390157968924341*x**4 + 1.0943010675397238*x**3 + -5.8679379334857495*x**2 + 16.93882060153151*x**1 + -21.393033919943562*x**0) # s10f
def s11f(x): x = math.log(x); return 2.71828182**(-2.811472792003724e-7*x**8 + 0.000029426676423522086*x**7 + -0.001327581582996746*x**6 + 0.03370258133848332*x**5 + -0.5264804569064836*x**4 + 5.182286128865138*x**3 + -31.370335574726536*x**2 + 106.33352457694215*x**1 + -156.27112169272712*x**0) # s11f
def s12f(x): x = math.log(x); return 2.71828182**(-1.4128335902921577e-7*x**8 + 0.000015205413332326015*x**7 + -0.000704362536394125*x**6 + 0.018325915826944407*x**5 + -0.29275414769851194*x**4 + 2.9398990000233227*x**3 + -18.105396339779073*x**2 + 62.09769995964163*x**1 + -92.61680323571747*x**0) # s12f
def s13f(x): x = math.log(x); return 2.71828182**(4.258360459188745e-8*x**8 + -0.0000037375539789571868*x**7 + 0.0001373335577411209*x**6 + -0.0027372957947536464*x**5 + 0.03196224396739598*x**4 + -0.21883372411714921*x**3 + 0.8343120258806735*x**2 + -1.912314669444785*x**1 + 0.7452953921862973*x**0) # s13f
def s14f(x): x = math.log(x); return 2.71828182**(-1.7775650830427714e-7*x**8 + 0.000018506795725551936*x**7 + -0.0008341144186295757*x**6 + 0.02123819552208469*x**5 + -0.33377863052110485*x**4 + 3.311356343138429*x**3 + -20.21029321879491*x**2 + 68.89693205452834*x**1 + -102.17968615477929*x**0) # s14f
def s15f(x): x = math.log(x); return 2.71828182**(-1.083904367610668e-7*x**8 + 0.00001125632714037739*x**7 + -0.000506958865353779*x**6 + 0.012927658118604341*x**5 + -0.2039725948292568*x**4 + 2.036153856616786*x**3 + -12.521274410228889*x**2 + 42.889422644783686*x**1 + -64.40113182162997*x**0) # s15f
def s16f(x): x = math.log(x); return 2.71828182**(-8.318887257595798e-8*x**8 + 0.000008612054740972736*x**7 + -0.00038581081677569904*x**6 + 0.009769970009425555*x**5 + -0.15291372655930463*x**4 + 1.513076360964339*x**3 + -9.212426654547409*x**2 + 31.089804947426835*x**1 + -46.26000932414679*x**0) # s16f
def s17f(x): x = math.log(x); return 2.71828182**(-7.692418034149814e-8*x**8 + 0.000008074844525914391*x**7 + -0.0003671909746096129*x**6 + 0.009443036154588646*x**5 + -0.15009608695245397*x**4 + 1.507660094576563*x**3 + -9.310901835725904*x**2 + 31.84811752723755*x**1 + -47.94229484437584*x**0) # s17f
fs = [s1f, s2f, s3f, s4f, s5f, s6f, s7f, s8f, s9f, s10f, s11f, s12f, s13f, s14f, s15f, s16f, s17f] # s17f
roughness = [0.05, 0.04, 0.03, 0.02, 0.015, 0.01, 0.005, 0.002, 0.001, 5e-4, 2e-4, 1e-4, 5e-5, 1e-5, 5e-6, 1e-6, 0] # s17f
moody_data = [[r, f] for r,f in zip(roughness, fs)]                              # s17f
def moody(e, Re):                                                                # moody
    """Calculates the friction coefficient using relative pipe roughness and reynolds number.
Example::

    kph.moody(1.3e-3, 1e5) # returns 0.023220729858510668
"""                                                                              # moody
    if e <= 0 or e >= 0.05: raise Exception("Relative roughness has to be between 0 and 0.05") # moody
    if Re < 0: raise Exception("Reynolds number can't be less than zero")        # moody
    if Re > 1e8: raise Exception("Reynolds number over 1e8, which is unrealistically high. Likely you made an error somewhere else in your calculations") # moody
    if Re < 2000: return 64/Re # laminar flow region                             # moody
    for i in range(len(moody_data)-1):                                           # moody
        if moody_data[i][0] > e >= moody_data[i+1][0]:                           # moody
            e1, f1 = moody_data[i+1] # lower bound                               # moody
            e2, f2 = moody_data[i]   # upper bound                               # moody
            alpha = (e-e1)/(e2-e1)                                               # moody
            return f1(Re)*(1-alpha) + f2(Re)*alpha                               # moody
    raise Exception("Unreachable")                                               # moody
met_pattern = r'^(-*\d+(\.\d+)?)\s*(.+)$'                                        # moody
prefixes = [["a", -18], ["f", -15], ["p", -12], ["n", -9], ["u", -6], ["m", -3], ["c", -2], ["d", -1], ["", 0], ["k", 3], ["M", 6], ["G", 9], ["T", 12], ["P", 15]] # moody
unitD = {**{"ton":1e3,"h":3600,"ha":10000,"bar":100000,"atm":101325,"gal":3.78541e-3,"min":60,"hr":3600,"psi":6894.76,"gpm":6.30902e-5}, # moody
         **{f"{a}m": 10**b for a,b in prefixes}, **{f"{a}s": 10**b for a,b in prefixes}, **{f"{a}A": 10**b for a,b in prefixes}, **{f"{a}g": 10**(b-3) for a,b in prefixes}, # moody
         **{f"{a}Pa": 10**b for a,b in [["m",-3],["",0],["k",3],["M",6],["G",9]]}, **{f"{a}N": 10**b for a,b in prefixes}, # moody
         **{f"{a}L": 10**(b-3) for a,b in [["p",-12],["n",-9],["u",-6],["m",-3],["",0]]}} # moody
def met(s:str="3m^3/s") -> float:                                                # met
    """Converts any number into standard metric units.
Example::

    met("3km")       # returns 3000
    met("3.6km^2/h") # returns 1000
    met("4 kPa*s")   # returns 4000

You can also use this to convert any unit into any other unit::

    met("3m^3/h") / met("1L/s") # converts from 3 m^3/h to L/s

The recognized units are available in ``met.unitD``. Add to that dictionary if
you want to expand the units that this function recognizes.

Note that when parsing the units, this uses :meth:`eval`(), which can be dangerous.
Don't use this method on untrusted input, or use it at yr own risk."""           # met
    match = re.match(met_pattern, s.strip())                                     # met
    if not match: raise Exception(f"Can't parse '{s}', no regex matches found!") # met
    return float(match.group(1))*eval(match.group(3).replace("^", "**"), None, unitD) # met
met.unitD = unitD                                                                # met
pi = 3.141592653589793                                                           # met
def pDrop(flowRate, diameter=0.019, length=10, roughness=0.0025, rho=1000, mu=0.001, returnVel=False): # pDrop
    """Calculates pressure drop of water through a circular pipe.
Example::

    kph.pDrop(met("10L/s"), met("90mm"), met("1km"))/met("1bar") # return 2.3126

This calculates the pressure drop through a 90mm diameter 1km pipe with 10L/s throughput,
enough for 1 hectares of grass

:param flowRate: liquid flow rate (m^3/s)
:param diameter: pipe diameter (m)
:param length: pipe length (m)
:param roughness: absolute roughness (mm)
:param rho: liquid density (kg/m^3)
:param mu: liquid dynamic viscosity (Pa*s)

Quick (absolute) roughness (mm) table:
- Concrete, coarse: 0.25
- Concrete, new smooth: 0.025
- Drawn tubing: 0.0025
- Glass, plastic, perspex: 0.0025
- Iron, cast: 0.25
- Sewers, old: 3.0
- Steel, mortar lined: 0.1
- Steel, rusted: 0.5
- Steel, structural or forged: 0.025
- Water mains, old: 1.0"""                                                       # pDrop
    A = pi*(diameter/2)**2 # m^2                                                 # pDrop
    flowVel = flowRate/A # m/s                                                   # pDrop
    Re = rho*flowVel*diameter/mu                                                 # pDrop
    f = moody(roughness/(diameter*1000), Re)                                     # pDrop
    if Re < 2000: ans = 8*mu*length*flowRate/(pi*(diameter/2)**4)                # pDrop
    else: ans = f*length*rho*flowVel**2/(2*diameter)                             # pDrop
    return (ans, flowVel) if returnVel else ans                                  # pDrop

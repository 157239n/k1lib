# AUTOGENERATED FILE! PLEASE DON'T EDIT
import math as _math, k1lib as _k1lib
import matplotlib.pyplot as _plt, numpy as _np
from itertools import accumulate as _accumulate
def combine(lambdas:list, ratios:list=None) -> callable:
    """Combine multiple different schedules.
    Args:
        ratios: list[float], weighting diferent
            functions. Does not have to add up to 1.
        lambdas: list[callable], functions with 1 
            float input in [0, 1]"""
    if ratios == None: ratios = [1] * len(lambdas)
    ratios = _np.array(ratios)
    ratios = ratios / ratios.sum()
    checkpoints = [0] + list(_accumulate(ratios))
    def f(x):
        for idx, checkpoint in enumerate(checkpoints):
            if checkpoint > x: break
        a = checkpoints[idx - 1]
        return lambdas[idx - 1]((x - a)/(checkpoints[idx] - a))
    return f
def decorate(f:callable) -> callable:
    """Decorator, transforms f(low, high, x) to (low, high) -> f(x)."""
    def _f(low, high): return lambda x: f(low, high, x)
    _f.__doc__ = f.__doc__; return _f
class ParamScheduler(_k1lib.Callback):
    def __init__(self, param:str, schedule:callable):
        super(ParamScheduler, self).__init__(); self.param = param; self.schedule = schedule
    def startBatch(self):
        if self.model.training:
            for paramGroup in self.opt.param_groups:
                paramGroup[self.param] = self.schedule(self.progress)
    def _ipython_display_(self):
        print(f"'{self.param}' scheduler")
        x = _np.linspace(0, 1, 1000); y = [self.schedule(x) for x in x]; _plt.plot(x, y)
@decorate
def linear(low, high, x): return low + x * (high - low)
@decorate
def cosine(low, high, x): return low + (high - low) * (1 + _math.cos(_math.pi * (1-x))) / 2
def oneCycle(low, high): return combine([cosine(0.8 * low + 0.2 * high, high), cosine(high, low)], [0.3, 0.7])
_en4 = _math.e**-3
@decorate
def decay(low, high, x): return (_math.exp(-x*4+1) - _en4) / (_math.e - _en4) * (high - low) + low
def plateau(low, high): return decay(high, low)
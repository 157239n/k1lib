# AUTOGENERATED FILE! PLEASE DON'T EDIT
import io, sys, warnings, time, k1lib
__all__ = ["captureStdout", "ignoreWarnings", "timer"]
class captureStdout(list):
    """Captures every print() statement. Taken from https://stackoverflow.com/questions/16571150/how-to-capture-stdout-output-from-a-python-function-call.
Example::

    with k1lib.captureStdout() as outer:
        print("something")
        with k1lib.captureStdout() as inner:
            print("inside inner")
        print("else")
    # prints "['something', 'else']"
    print(outer)
    # prints "['inside inner']"
    print(inner)

Note that internally, this replaces :data:`sys.stdout` as :class:`io.StringIO`, so
might not work property if you have fancy :class:`bytes` stuff going on."""
    def __enter__(self):
        self._stdout = sys.stdout
        sys.stdout = self._stringio = io.StringIO(); return self
    def __exit__(self, *args):
        self.extend(self._stringio.getvalue().splitlines())
        del self._stringio; sys.stdout = self._stdout
class ignoreWarnings:
    """Context manager to ignore every warning.
Example::

    import warnings
    with k1lib.ignoreWarnings():
        warnings.warn("some random stuff") # will not show anything"""
    def __enter__(self):
        self.ctx = warnings.catch_warnings()
        self.ctx.__enter__()
        warnings.simplefilter("ignore")
    def __exit__(self, *ignored):
        self.ctx.__exit__(*ignored)
from contextlib import contextmanager
@contextmanager
def timer():
    """Times generic code.
Example::

    with k1lib.timer() as t:
        time.sleep(1.1)
    # prints out float close to 1.1
    print(t())

The with- statement will actually return a :class:`~k1lib.Wrapper` with value
None. The correct time will be deposited into it after the code block ends."""
    w = k1lib.Wrapper(None)
    beginTime = time.time()
    yield w
    w.value = time.time() - beginTime
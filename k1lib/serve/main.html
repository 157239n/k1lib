<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="TITLE" />
    <meta charset="UTF-8" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;1,100;1,300;1,400;1,700&display=swap" rel="stylesheet" />
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$$$','$$$'], ['\\(','\\)']]}});</script>
    <title>TITLE</title>
    <style>
      /* -------------------------- checkbox -------------------------- */

      .grid-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, 300px);
        /* minmax(300px, 1fr)*/
        grid-gap: 30px;
        padding: 20px;
        justify-items: center;
        justify-content: center;
        align-items: start;
      }
      .box {
        padding: 2em;
      }
      .item {
        margin-bottom: 2em;
      }

      /* checkbox-rect2 */
      input[type="checkbox"] {
        display: none;
      }
      input[type="checkbox"] + label {
        display: block;
        position: relative;
        padding-left: 35px;
        margin-bottom: 20px;
        font: 14px/20px "Open Sans", Arial, sans-serif;
        cursor: pointer;
      }
      input[type="checkbox"]:hover + label:hover {
        color: rgb(23, 86, 228);
      }
      input[type="checkbox"]:hover + label:before {
        border: 1px solid #343a3f;
        box-shadow: 2px 1px 0 #343a3f;
      }
      input[type="checkbox"] + label:last-child {
        margin-bottom: 0;
      }
      input[type="checkbox"] + label:before {
        content: "";
        display: block;
        width: 1em;
        height: 1em;
        border: 1px solid #343a3f;
        border-radius: 0.2em;
        position: absolute;
        left: 0;
        top: 0;
        -webkit-transition: all 0.2s, background 0.2s ease-in-out;
        transition: all 0.2s, background 0.2s ease-in-out;
        background: rgba(255, 255, 255, 0.03);
        box-shadow: -2px -1px 0 #343a3f;
        background: #f3f3f3;
      }
      input[type="checkbox"]:checked + label:before {
        border: 2px solid #fff;
        border-radius: 0.3em;
        background: #50565a;
        box-shadow: 2px 1px 0 #50565a;
      }
      /* checkbox-rect2 end */

      /* -------------------------- range -------------------------- */

      input[type="range"] {
        height: 32px;
        -webkit-appearance: none;
        margin: 10px 0;
        width: 100%;
      }
      input[type="range"]:focus {
        outline: none;
      }
      input[type="range"]::-webkit-slider-runnable-track {
        width: 100%;
        height: 16px;
        cursor: pointer;
        box-shadow: 0px 0px 0px #000000;
        background: #b6b6b6;
        border-radius: 25px;
        border: 1px solid #8a8a8a;
      }
      input[type="range"]::-webkit-slider-thumb {
        box-shadow: 1px 1px 1px #828282;
        border: 1px solid #8a8a8a;
        height: 24px;
        width: 35px;
        border-radius: 6px;
        background: #dadada;
        cursor: pointer;
        -webkit-appearance: none;
        margin-top: -5px;
      }
      input[type="range"]:focus::-webkit-slider-runnable-track {
        background: #b6b6b6;
      }
      input[type="range"]::-moz-range-track {
        width: 100%;
        height: 16px;
        cursor: pointer;
        box-shadow: 0px 0px 0px #000000;
        background: #b6b6b6;
        border-radius: 25px;
        border: 1px solid #8a8a8a;
      }
      input[type="range"]::-moz-range-thumb {
        box-shadow: 1px 1px 1px #828282;
        border: 1px solid #8a8a8a;
        height: 24px;
        width: 35px;
        border-radius: 6px;
        background: #dadada;
        cursor: pointer;
      }
      input[type="range"]::-ms-track {
        width: 100%;
        height: 16px;
        cursor: pointer;
        background: transparent;
        border-color: transparent;
        color: transparent;
      }
      input[type="range"]::-ms-fill-lower {
        background: #b6b6b6;
        border: 1px solid #8a8a8a;
        border-radius: 50px;
        box-shadow: 0px 0px 0px #000000;
      }
      input[type="range"]::-ms-fill-upper {
        background: #b6b6b6;
        border: 1px solid #8a8a8a;
        border-radius: 50px;
        box-shadow: 0px 0px 0px #000000;
      }
      input[type="range"]::-ms-thumb {
        margin-top: 1px;
        box-shadow: 1px 1px 1px #828282;
        border: 1px solid #8a8a8a;
        height: 24px;
        width: 35px;
        border-radius: 6px;
        background: #dadada;
        cursor: pointer;
      }
      input[type="range"]:focus::-ms-fill-lower {
        background: #b6b6b6;
      }
      input[type="range"]:focus::-ms-fill-upper {
        background: #b6b6b6;
      }

      /* -------------------------- toast -------------------------- */
      
      #toast {
        position: fixed;
        max-width: 40vw;
        top: 70vh;
        left: 50vw;
        transform: translateX(-50%);
        background-color: #f0e68cff;
        opacity: 0;
        color: #111111ff;
        transition: opacity 0.3s;
        text-align: center;
        padding: 8px 30px;
        font-size: 1.5em;
        z-index: 50000;
        border-radius: 32px;
        color: #111111 !important;
      }

      @media only screen and (max-width: 600px) {
        #toast {
          top: unset;
          max-width: unset;
          transform: unset;
          border-radius: unset;
          font-size: 1em;
          width: 100vw;
          bottom: 0;
          left: 0;
        }
      }

      #toast.activated {
        opacity: 1;
      }
      
      /* -------------------------- custom -------------------------- */

      #wrapper {
        max-width: 1300px;
        padding: 20px 30px;
        margin: 0 auto;
        font-size: 1.3em;
      }

      a {
        text-decoration: none;
        color: blue;
      }

      body {
        font-family: Lato;
      }

      h1 {
        font-size: 2.2em;
        color: #ED225D;
        font-weight: 300;
        margin-top: 20px;
      }
      
      h2 {
        font-size: 1.7em;
        font-weight: 300;
        margin: 20px 0px;
      }
      
      h3 {
        font-weight: 400;
      }

      @media (max-width: 600px) {
        #wrapper {
          padding: 0px;
        }
        h1 {
          font-size: 1.8em;
          margin-top: 0px;
        }
      }

      @media (max-width: 1100px) {
        #wrapper {
          max-width: 1000px;
        }
      }

      .block {
        flex: 1;
        margin: 10px;
        box-shadow: 0 3px 5px rgb(0 0 0 / 30%);
        border-radius: 15px;
        padding: 16px;
      }

      .block:hover {
        box-shadow: 0 3px 10px rgb(0 0 0 / 60%);
      }

      input[type="text"] {
        padding: 5px 10px;
        font-size: 1em;
        border-radius: 10px;
      }

      input[type="password"] {
        padding: 5px 10px;
        font-size: 1em;
        border-radius: 10px;
      }

      input[type="range"] {
        width: 200px;
      }

      input[type="file"] {
        font-size: 1em;
      }
      
      textarea {
        font-size: 1em;
        min-width: 400px;
        padding: 10px;
        width: 100%;
      }

      .block {
        flex: 1;
      }
      
      .block > div:first-child {
        margin-bottom: 10px;
        font-size: 1.2em;
      }

      .scan {
        box-shadow: 0px 3px 8px rgba(0, 0, 0, 0.2);
        width: fit-content;
        margin: 10px;
        padding: 10px 15px;
        display: flex;
        align-items: center;
        border-radius: 8px;
      }

      .scan > .marker {
        width: 16px;
        height: 16px;
        border-radius: 8px;
        background-color: red;
        margin: 0px 15px 0px 5px;
      }

      .btn {
        margin: 10px;
        box-shadow: 0 3px 5px rgb(0 0 0 / 30%);
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 1em;
        cursor: pointer;
        user-select: none;
      }

      .btn:hover {
        box-shadow: 0 3px 10px rgb(0 0 0 / 60%);
      }
      
      #result h1 {
        font-size: 1em;
      }
      
      select {
        font-size: 1em;
        padding: 5px;
      }
      
      .pre {
        border: 1px solid black;
        padding: 10px;
        overflow-x: auto
      }
    </style>
  </head>
  <body>
    <div id="k1lib_serve_apiKey" style="display:none"></div>
    <div id="wrapper">
      <h1>TITLE</h1>
      <h2>Intro</h2>
      <div id="intro">INTRO</div>
      <div style="display: flex; flex-direction: row; align-items: center; margin-left: 10px; overflow-x: auto">
        <div style="margin-right: 10px">
          <label for="autoRun_dropdown" style="font-size: 1em">Auto run</label>
          <select id="autoRun_dropdown" onchange="autoRunUpdate()" style="margin-left: 8px">
            <option value="0" selected>Off</option>
            <option value="-1">On param changed</option>
            <option value="1">Every 1s</option>
            <option value="3">Every 3s</option>
            <option value="10">Every 10s</option>
            <option value="30">Every 30s</option>
          </select>
        </div>
        <div class="btn" onclick="run()">Run</div>
        <div class="scan" id="scan">
          <div class="marker"></div>
          <div class="label">Server offline</div>
        </div>
        <div class="scan" id="idle"><div class="label">Idle</div></div>
      </div>
      <h2>Parameters</h2>
      <div
        id="blocks"
        style="
          display: flex;
          flex-direction: row;
          justify-content: space-between;
          flex-wrap: wrap;
        "
      ></div>
      <h2>Result<span id="resType"></span></h2>
      <div id="result">(none yet)</div>
      <h2>Sample api request</h2>
      <div id="apiRequest"></div>
      <h2>Source code</h2>
      <div id="sourceCode">SOURCE_CODE</div>
    </div>
    <div id="toast"></div>
  </body>
  <script src="https://cdn.jsdelivr.net/npm/js-base64@3.7.2/base64.min.js"></script>
  <script>
    class Toast {
      constructor() {
        /** @type {number} this.instances */ this.instances = 0; // this is so that only the latest call's turnOff() will actually turn it off
        /** @type {jQuery} this.objectReference */ this.objectReference = document.querySelector("#toast");
      }
      display(content, timeout = 1000) {
        this.instances++;
        this.objectReference.innerHTML = content;
        this.objectReference.classList.add("activated");
        setTimeout(this.turnOff, timeout);
      }

      noInternet = (retrying) => (retrying ? this.display("No internet, retrying...") : this.display("No internet!"));
      /** Displays a message, and keeps it online until another display() is called. */
      persistTillNextDisplay = (content) => (this.objectReference.innerHTML = content, this.objectReference.classList.remove("activated"));
      /** Fades out the toast. Expected to be called by a timeout only. */
      turnOff = () => (((toast.instances === 1) ? toast.objectReference.classList.remove("activated") : ""), toast.instances--);
    }

    /** @type {Toast} toast */ const toast = new Toast();
    
    let meta = JSON.parse(atob("META_JSON"));
    document.querySelector("#resType").innerHTML = ` - ${meta.annos.return}`;
    let prefix = "SERVER_PREFIX";
    let [values, idxToArg] = [{}, {}]; // Dict[arg, value], Dict[idx, arg]
    for (let arg of meta.args) values[arg] = null;
    let [autoInc, autoRun] = [1, 0]; // autoRun can take on these values: 0 (off), -1 (on param change), 1 (every 1s), 3 (every 3s), and so on
    let [requests, newRequest, nRequests, requestLastSent] = [[], false, 0, 0]; // 'newRequest' is set to true whenever any part of the system wants to trigger an update. The debounce mechanism will auto schedule the right moment to send the request
    setInterval(() => { // to rate limit the requests & debouncing
      if (!nRequests && newRequest && Date.now() / 1000 - requestLastSent > 0.2) {
        run(); newRequest = false;
        requestLastSent = Date.now() / 1000;
      }
    }, 100);
    const updated = () => (autoRun === -1 ? (newRequest = true) : 0);
    autoRun_setInterval_handle = null;
    const autoRunUpdate = () => {
      autoRun = parseInt(document.querySelector("#autoRun_dropdown").value);
      if (autoRun_setInterval_handle) {
        clearInterval(autoRun_setInterval_handle);
        autoRun_setInterval_handle = null;
      }
      if (autoRun > 0.1) { autoRun_setInterval_handle = setInterval(() => { newRequest = true; }, autoRun*1000); }
      updated();
    }
    // const autoRunToggle = () => {autoRun = !autoRun; updated();};
    function base64ToArrayBuffer(base64) {
        var binaryString = window.atob(base64);
        var binaryLen = binaryString.length;
        var bytes = new Uint8Array(binaryLen);
        for (var i = 0; i < binaryLen; i++) {
            var ascii = binaryString.charCodeAt(i);
            bytes[i] = ascii;
        }
        return bytes;
    }
    function saveByteArray(byte) { // download to user's disk
        var blob = new Blob([byte], {type: "application/octet-stream"});
        var link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.download = "data";
        link.click();
    };
    const escapeHtml = (unsafe) => {
      return unsafe.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#039;');
    }
    async function run() {
      nRequests+=2;
      idle.innerHTML = "Executing...";
      // trying to inject the api key from the chrome extension
      const a = meta.args.filter((arg) => meta.annos[arg] === "apiKey");
      if (a.length > 0) values[a[0]] = values[a[0]] || document.querySelector("#k1lib_serve_apiKey").innerHTML;
      // console.log(`Request body:`, values);
      const res = await fetch(prefix, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(values),
      });
      console.log("Sent request");
      nRequests--;
      try {
        const obj = await res.json();
        if (obj.success) {
          const text = obj.data;
          const anno = meta.annos.return;
          if (["int", "float", "text", "checkbox"].includes(anno)) {
            const a = `${text}`.replace("&", "&quot;").replace("<", "&lt;").replace(">", "&gt;");
            result.innerHTML = `<pre class="pre">${a}</pre>`;
          } else if (["bytes", "serialized"].includes(anno)) {
            const _byte = base64ToArrayBuffer(text)
            const href = window.URL.createObjectURL(new Blob([_byte], {type: "application/octet-stream"}))
            result.innerHTML = `<a href="${href}" download="data.bin">Download data (size: ${_byte.length/1000} kB)</a>`
          } else if (anno === "json") {
            result.innerHTML = `<pre class="pre">${JSON.stringify(text, null, 2)}</pre>`
          } else if (anno === "html") {
            const scriptEl = document.createRange().createContextualFragment(atob(text));
            result.innerHTML = "";
            result.append(scriptEl);
            //result.innerHTML = atob(text);
          } else if (anno === "image") result.innerHTML = `<div style="overflow: auto;"><img style="width: 100%; object-fit: cover;" src="data:image/jpg;base64, ${text}" alt="Result image" /></div>`
          else throw new Error(`Return value '${anno}' not recognized`);
          nRequests--;
        } else { result.innerHTML = `<pre class="pre">${obj.reason}</pre>`; nRequests--; }
      } catch (e) { nRequests--; result.innerHTML = `<pre class="pre">Failed on JS side:\n${escapeHtml(e.stack)}</pre>`; }
    }
    setInterval(() => {
      idle.innerHTML = nRequests > 1.9 ? "Executing..." : (nRequests > 0.9 ? "Executed, displaying..." : "Idle");
    }, 100)

    const text_transforms = {};
    function textBox(arg, doc, anno, def, transformF=((x) => x)) {
      const i = ++autoInc; setTimeout(() => cb_textBox(i), 0); idxToArg[i] = arg; text_transforms[i] = transformF;
      setTimeout(() => { const e = document.querySelector(`#textBox_${i}`); e.value = def[0]; e.dispatchEvent(new Event("input")); }, 0);
      if (def[1]) return `
        <div class="block">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
          <textarea id="textBox_${i}" rows="7" oninput="cb_textBox(${i})"></textarea>
        </div>`;
      if (def[2]) return `
        <div class="block">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
          <input id="textBox_${i}" type="password" oninput="cb_textBox(${i})" />
        </div>`;
      return `
        <div class="block">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
          <input id="textBox_${i}" type="text" oninput="cb_textBox(${i})" />
        </div>`;
    }

    function cb_textBox(i) {
      const value = document.querySelector(`#textBox_${i}`).value;
      try {
        values[idxToArg[i]] = text_transforms[i](value); updated();
      } catch (e) {
        result.innerHTML = `<pre class="pre">Failed on JS side on update textbox ${i}:\n${escapeHtml(e.stack)}\n\nContent:\n'${value}'</pre>`;
      }
    }

    function dateBox(arg, doc, anno, def) {
      const i = ++autoInc; idxToArg[i] = arg
      let [value, minDate, maxDate] = def;
      setTimeout(() => cb_dateBox(i), 0);
      value = value ? `value="${value}" ` : "";
      minDate = minDate ? `min="${minDate}" ` : "";
      maxDate = maxDate ? `max="${maxDate}" ` : "";
      return `
        <div class="block">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
          <input
            id="dateBox_${i}"
            type="datetime-local"
            ${value} ${minDate} ${maxDate}
            oninput="cb_dateBox(${i})"
          />
        </div>`;
      return `
      `;
    }

    function cb_dateBox(i) {
      values[idxToArg[i]] = document.querySelector(`#dateBox_${i}`).value; updated();
    }


    function slider(arg, doc, anno, def) {
      const i = ++autoInc; idxToArg[i] = arg; let value, start, stop, step;
      [value, start, stop, step] = def
      setTimeout(() => cb_slider(i), 0);
      return `
        <div class="block">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
            <div style="display: flex; flex-direction: row; align-items: center">
              <input id="slider_${i}" type="range" min="${start}" max="${stop}" step="${step}" value="${value}" oninput="cb_slider(${i})"/>
              <div id="slider_${i}_value" style="margin-left: 10px; min-width: 50px"></div>
            </div>
        </div>`;
    }

    function cb_slider(i) {
      values[idxToArg[i]] = document.querySelector(`#slider_${i}`).value;
      document.querySelector(`#slider_${i}_value`).innerHTML = values[idxToArg[i]];
      updated();
    }

    function checkBox(arg, doc, anno, def) {
      const i = ++autoInc; idxToArg[autoInc] = arg; values[idxToArg[i]] = false;
      setTimeout(() => document.querySelector(`#checkBox_${i}`).click(), 0);
      if (!def) setTimeout(() => document.querySelector(`#checkBox_${i}`).click(), 0);
      return `
        <div class="block">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
          <div>
            <input id="checkBox_${i}" type="checkbox" name="check" oninput="cb_checkBox(${i})" />
            <label id="checkBox_${i}_value" for="checkBox_${i}" style="font-size: 1em"></label>
          </div>
        </div>`;
    }

    function cb_checkBox(i) {
      values[idxToArg[i]] = !values[idxToArg[i]];
      document.querySelector(`#checkBox_${i}_value`).innerHTML = values[idxToArg[i]];
      updated();
    }

    function fileUpload(arg, doc, anno, def) {
      const i = ++autoInc; idxToArg[autoInc] = arg; values[arg] = def;
      return `
        <div class="block" style="overflow-x: auto; min-width: 300px">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
          <input id="fileUpload_${i}" type="file" onchange="cb_fileUpload(${i})" />
        </div>`;
    }

    function cb_fileUpload(i) {
      const elem = document.querySelector(`#fileUpload_${i}`);
      if (elem.files.length == 0) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          window.im = e.target.result; l = e.target.result.split(",")
          values[idxToArg[i]] = l[l.length - 1];
        } catch (e) {
          toast.display("Can't upload file");
          console.log("Can't upload file: ", e);
          elem.value = null;
        }
      };
      reader.readAsDataURL(elem.files[0]);
      updated();
    }

    function dropdown(arg, doc, anno, def) {
      const i = ++autoInc; idxToArg[autoInc] = arg; values[arg] = def[1];
      const selects = def[1].map((e, i) => `<option value="${e}" ${def[0] === i ? 'selected' : ''}>${e}</option>`).join("");
      setTimeout(() => cb_dropdown(i), 0);
      return `
        <div class="block" style="overflow-x: auto; min-width: 300px">
          <div>${arg} (${anno}): ${doc || "(no docs)"}</div>
          <select id="dropdown_${i}" onchange="cb_dropdown(${i})">${selects}</select>
        </div>`;
    }

    function cb_dropdown(i) {
      values[idxToArg[i]] = document.querySelector(`#dropdown_${i}`).value;
      updated();
    }

    let lastOnline = 0;
    async function healthCheck() {
      try {
        let res = await fetch(`${prefix}/healthCheck`);
        if ((await res.text()) == "ok") lastOnline = Date.now() / 1000;
      } catch {}
      await new Promise((r) => setTimeout(r, 1000));
      healthCheck();
    }
    healthCheck();
    const scanLabel = document.querySelector(".scan .label");
    const marker = document.querySelector(".scan .marker");
    setInterval(() => {
      if (Date.now() / 1000 - lastOnline < 2) {
        marker.style.backgroundColor = "green";
        scanLabel.innerHTML = "Server online";
      } else {
        marker.style.backgroundColor = "red";
        scanLabel.innerHTML = "Server offline";
      }
    }, 1000);

    let n = meta.args.length;
    const intro = document.querySelector("#intro");
    const blocks = document.querySelector("#blocks");
    const result = document.querySelector("#result");
    const idle = document.querySelector("#idle");
    let blocksHtml = "";
    for (let arg of meta.args) {
      let anno = meta.annos[arg]; let def = meta.defaults[arg]; let doc = meta.docs[arg];
      if (anno === "int" || anno === "float" || anno === "text") blocksHtml += textBox(arg, doc, anno, def);
      if (anno === "apiKey") blocksHtml += textBox(arg, doc, anno, def);
      if (anno === "date") blocksHtml += dateBox(arg, doc, anno, def);
      if (anno === "json") blocksHtml += textBox(arg, doc, anno, [JSON.stringify(def[0], null, 2), def[1]], (x) => {return x ? JSON.parse(x) : ""});
      if (anno === "checkbox") blocksHtml += checkBox(arg, doc, anno, def);
      if (anno === "slider") blocksHtml += slider(arg, doc, anno, def);
      if (anno === "bytes" || anno === "image" || anno === "serialized") blocksHtml += fileUpload(arg, doc, anno, def);
      if (anno === "dropdown") blocksHtml += dropdown(arg, doc, anno, def);
    }
    blocks.innerHTML = blocksHtml;
    document.querySelector("#k1lib_serve_apiKey").innerHTML = "some key";
    // intro.innerHTML = `${meta.mainDoc}`.replace("\n", "<br>");
    // document.querySelector("#sourceCode").innerHTML = `<pre class="pre">${escapeHtml(meta.source)}</pre>`;

    setTimeout(() => {
      let jsReqBody = ""; let pyReqBody = "";
      for (let arg of meta.args) {
        const anno = meta.annos[arg];
        if (anno === "json") {
          const s = `    "${arg}": ${JSON.stringify(values[arg])},\n`; jsReqBody += s; pyReqBody += s;
        } else if (anno === "int" || anno === "float" || anno === "slider") {
          const s = `    "${arg}": ${values[arg]},\n`; jsReqBody += s; pyReqBody += s;
        } else if (anno === "checkbox") {
          jsReqBody += `    "${arg}": ${values[arg] ? 'true' : 'false'},\n`;
          pyReqBody += `    "${arg}": ${values[arg] ? 'True' : 'False'},\n`;
        } else {
          let s = `${values[arg]}`.split("\n")[0];
          s = (s.length > 23) ? s.slice(0, 20) + "..." : s
          jsReqBody += `    "${arg}": \`${s}\`,\n`;
          pyReqBody += `    "${arg}": """${s}""",\n`;
        }
      }
      const base64_js = meta.annos.return === "html" || meta.annos.return === "bytes";
      const base64_py = meta.annos.return === "html" || meta.annos.return === "bytes" || meta.annos.return === "image";
      document.querySelector("#apiRequest").innerHTML = `
<h3>Javascript</h3>
<pre class="pre">
let result = ${base64_js ? 'atob(' : ''}(await (await fetch("${prefix}", {
  method: "POST",
  body: JSON.stringify({
${jsReqBody.trimEnd()}
  }),
  headers: {
    "Content-Type": "application/json",
  }
})).json()).data${base64_js ? ')' : ''};</pre>
<h3>Python</h3>
<pre class="pre">
import requests${base64_py ? ', base64' : ''}
result = ${base64_py ? 'base64.b64decode(' : ''}requests.post("${prefix}", json={
${pyReqBody.trimEnd()}
}).json()["data"]${base64_py ? ').decode()' : ''}
</pre>
<h3>Python - k1lib</h3>
<pre class="pre">
from k1lib.imports import *
{
${pyReqBody.trimEnd()}
} | kapi.post("${prefix}") | aS(json.loads) | op()["data"]${base64_py ? ' | aS(base64.b64decode) | op().decode()' : ''}
</pre>`;
    }, 0);
  </script>
</html>
